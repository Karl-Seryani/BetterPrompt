import Database from 'better-sqlite3';
import * as path from 'path';
import { DATABASE_SCHEMA, UserTemplate, PromptHistory, AnalyticsEntry } from './schema';

/**
 * Database manager class for PromptForge
 * Handles all database operations using SQLite
 */
export class DatabaseManager {
  private db: Database.Database | null = null;
  private dbPath: string;

  constructor(storagePath: string) {
    this.dbPath = path.join(storagePath, 'promptforge.db');
  }

  /**
   * Initialize the database connection and create tables
   */
  public initialize(): void {
    if (this.db) {
      return; // Already initialized
    }

    this.db = new Database(this.dbPath);
    this.createTables();
  }

  /**
   * Create all required database tables and indexes
   */
  private createTables(): void {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    this.db.exec(DATABASE_SCHEMA.CREATE_USER_TEMPLATES);
    this.db.exec(DATABASE_SCHEMA.CREATE_PROMPT_HISTORY);
    this.db.exec(DATABASE_SCHEMA.CREATE_ANALYTICS);
    this.db.exec(DATABASE_SCHEMA.CREATE_PROMPT_HISTORY_INDEX);
    this.db.exec(DATABASE_SCHEMA.CREATE_ANALYTICS_INDEX);
  }

  /**
   * Close the database connection
   */
  public close(): void {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }

  /**
   * Insert a new user template
   */
  public insertTemplate(template: Omit<UserTemplate, 'id'>): number {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    const stmt = this.db.prepare(`
      INSERT INTO user_templates (name, content, category, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?)
    `);

    const result = stmt.run(
      template.name,
      template.content,
      template.category || null,
      template.created_at,
      template.updated_at
    );

    return result.lastInsertRowid as number;
  }

  /**
   * Get all user templates
   */
  public getAllTemplates(): UserTemplate[] {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    const stmt = this.db.prepare('SELECT * FROM user_templates ORDER BY created_at DESC');
    return stmt.all() as UserTemplate[];
  }

  /**
   * Insert a prompt history entry
   */
  public insertPromptHistory(history: Omit<PromptHistory, 'id'>): number {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    const stmt = this.db.prepare(`
      INSERT INTO prompt_history
      (original_prompt, enhanced_prompt, accepted, tokens_saved, timestamp, template_used)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    const result = stmt.run(
      history.original_prompt,
      history.enhanced_prompt,
      history.accepted ? 1 : 0,
      history.tokens_saved || 0,
      history.timestamp,
      history.template_used || null
    );

    return result.lastInsertRowid as number;
  }

  /**
   * Get prompt history with optional limit
   */
  public getPromptHistory(limit = 50): PromptHistory[] {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    const stmt = this.db.prepare(`
      SELECT * FROM prompt_history
      ORDER BY timestamp DESC
      LIMIT ?
    `);

    const results = stmt.all(limit) as Array<Omit<PromptHistory, 'accepted'> & { accepted: number }>;
    return results.map((row) => ({
      ...row,
      accepted: row.accepted === 1,
    }));
  }

  /**
   * Insert an analytics entry
   */
  public insertAnalytics(entry: Omit<AnalyticsEntry, 'id'>): number {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    const stmt = this.db.prepare(`
      INSERT INTO analytics (metric_name, value, timestamp)
      VALUES (?, ?, ?)
    `);

    const result = stmt.run(entry.metric_name, entry.value, entry.timestamp);
    return result.lastInsertRowid as number;
  }

  /**
   * Get analytics data for a specific metric
   */
  public getAnalytics(metricName: string, limit = 100): AnalyticsEntry[] {
    if (!this.db) {
      throw new Error('Database not initialized');
    }

    const stmt = this.db.prepare(`
      SELECT * FROM analytics
      WHERE metric_name = ?
      ORDER BY timestamp DESC
      LIMIT ?
    `);

    return stmt.all(metricName, limit) as AnalyticsEntry[];
  }
}
